var privateDataMap=new Map;class ListNode{static[Symbol.hasInstance](instance){try{instance.#data}catch(error){return!1}return!0}#data;value;constructor(value,list,index){if(!new.target)throw new TypeError("List.constructor");let currentNodeData=this.#data={node:this,listData:null,previous:null,next:null};this.value=value;let listData=privateDataMap.get(list);if(listData!==void 0){if(listData.length>=4294967295)throw new RangeError("argument list length >= 2 ** 32 - 1");if(typeof index!=="number")throw new TypeError("argument index is not a number");if(!Number.isInteger(index))throw new RangeError("argument index is not an integer");else if(index<0||index>listData.length)throw new RangeError("argument index is not valid");let targetNodeData=null,append=!1;if(currentNodeData.listData=listData,listData.length===0){listData.first=listData.last=currentNodeData,listData.length=1;return}else if(index===0)targetNodeData=listData.first;else if(index>=listData.length-1){if(targetNodeData=listData.last,index===listData.length)append=!0}else{let currentNodeData2,forwards,i;if(index<listData.length/2)forwards=!0,currentNodeData2=listData.first.next,i=1;else forwards=!1,currentNodeData2=listData.last.previous,i=listData.length-2;while(currentNodeData2){if(index===i){targetNodeData=currentNodeData2;break}if(forwards)currentNodeData2=currentNodeData2.next,i++;else currentNodeData2=currentNodeData2.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else listData.last=currentNodeData;currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else listData.first=currentNodeData;currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData}listData.length++}else if(list!==void 0)throw new TypeError("argument list is not a List instance")}list(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.listData?this.#data.listData.list:null}previous(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.previous?this.#data.previous.node:null}next(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.next?this.#data.next.node:null}prependTo(node){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}try{node.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}if(node===this)throw new ReferenceError("node");let currentNodeData=this.#data,targetNodeData=node.#data;if(currentNodeData===targetNodeData.previous)return this;let targetListData=targetNodeData.listData;if(!targetListData)targetNodeData.listData=targetListData=privateDataMap.get(new List),targetListData.first=targetNodeData,targetListData.last=targetNodeData,targetListData.length=1;else if(targetListData.length+1>4294967295)throw new RangeError("List length");let currentListData=this.#data.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--}if(currentNodeData.listData=targetListData,targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else targetListData.first=currentNodeData;return currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData,targetListData.length++,this}appendTo(node){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}try{node.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}if(node===this)throw new ReferenceError("node");let currentNodeData=this.#data,targetNodeData=node.#data;if(currentNodeData===targetNodeData.previous)return this;let targetListData=targetNodeData.listData;if(!targetListData)targetNodeData.listData=targetListData=privateDataMap.get(new List),targetListData.first=targetNodeData,targetListData.last=targetNodeData,targetListData.length=1;else if(targetListData.length+1>4294967295)throw new RangeError("List length");let currentListData=this.#data.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--}if(currentNodeData.listData=targetListData,targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else targetListData.last=currentNodeData;return currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData,targetListData.length++,this}insertInto(list,index){let currentNodeData=this.#data;try{}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let targetListData=privateDataMap.get(list);if(targetListData===void 0)throw new TypeError("list");else if(targetListData.length>=4294967295)throw new RangeError("list.length() >= 2 ** 32 - 1");if(typeof index!=="number")throw new TypeError("argument index is not a number");else if(!Number.isInteger(index))throw new RangeError("argument index is not an integer");else if(index<0||index>targetListData.length)throw new RangeError("argument index is not valid");let currentListData=currentNodeData.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--,currentNodeData.listData=null}let targetNodeData=null,append=!1;if(currentNodeData.listData=targetListData,targetListData.length===0)return targetListData.first=targetListData.last=currentNodeData,targetListData.length=1,this;else if(index===0)targetNodeData=targetListData.first;else if(index>=targetListData.length-1){if(targetNodeData=targetListData.last,index===targetListData.length)append=!0}else{let forwards,i;if(index<targetListData.length/2)forwards=!0,targetNodeData=targetListData.first.next,i=1;else forwards=!1,targetNodeData=targetListData.last.previous,i=targetListData.length-2;while(targetNodeData){if(index===i)break;if(forwards)targetNodeData=targetNodeData.next,i++;else targetNodeData=targetNodeData.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else targetListData.last=currentNodeData;currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else targetListData.first=currentNodeData;currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData}return targetListData.length++,this}remove(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let currentNodeData=this.#data,currentListData=currentNodeData.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentNodeData.previous=null,currentNodeData.next=null,currentListData.length--,currentNodeData.listData=null}return this}}var thisIsNotAList='"this" is not an instance of List';class List{static[Symbol.hasInstance](instance){try{instance.#data}catch(error){return!1}return!0}#data;constructor(...values){if(!new.target)throw new TypeError("List.constructor");this.#data={list:this,first:null,last:null,length:0},privateDataMap.set(this,this.#data);let length=values[0];if(values.length===1&&typeof length==="number"){if(!Number.isInteger(length)||length<0||length>4294967295)throw new RangeError("length");for(let i=0;i<length;i++)new ListNode(void 0,this,0)}else for(let value of values)new ListNode(value,this,this.#data.length)}first(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.first?this.#data.first.node:null}last(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.last?this.#data.last.node:null}length(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.length}at=(index)=>{try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof index!=="number")throw new TypeError("index");else if(!Number.isInteger(index))throw new RangeError("index");let listData=this.#data;if(index<0||index>=listData.length)throw new RangeError("index");let nodeData;if(index===0)nodeData=listData.first;else if(index===listData.length-1)nodeData=listData.last;else{let forwards,i;if(index<listData.length/2)forwards=!0,nodeData=listData.first.next,i=1;else forwards=!1,nodeData=listData.last.previous,i=listData.length-2;while(nodeData){if(index===i)break;if(forwards)nodeData=nodeData.next,i++;else nodeData=nodeData.previous,i--}}return nodeData.node};unshift(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}for(let i=0;i<values.length;i++)new ListNode(values[i],this,i);return this.#data.length}push(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}for(let value of values)new ListNode(value,this,this.#data.length);return this.#data.length}insert(index,...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}for(let i=0;i<values.length;i++)new ListNode(values[i],this,index+i);return this.#data.length}shift(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data;if(!listData.first)return null;else{let nodeData=listData.first;if(nodeData.next)nodeData.next.previous=null,listData.first=nodeData.next;else listData.first=listData.last=null;return listData.length--,nodeData.previous=null,nodeData.next=null,nodeData.listData=null,nodeData.node}}pop(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data;if(!listData.last)return null;else{let nodeData=listData.last;if(nodeData.previous)nodeData.previous.next=null,listData.last=nodeData.previous;else listData.first=listData.last=null;return listData.length--,nodeData.previous=null,nodeData.next=null,nodeData.listData=null,nodeData.node}}remove(index){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(!Number.isInteger(index))throw new TypeError("index");let listData=this.#data;if(index<0||index>listData.length-1)throw new RangeError("index");let nodeData=null;if(index===0)nodeData=listData.first;else if(index===listData.length-1)nodeData=listData.last;else{let forwards,i;if(index<listData.length/2)forwards=!0,nodeData=listData.first.next,i=1;else forwards=!1,nodeData=listData.last.previous,i=listData.length-2;while(nodeData){if(index===i)break;if(forwards)nodeData=nodeData.next,i++;else nodeData=nodeData.previous,i--}}if(nodeData.listData){if(nodeData.previous)nodeData.previous.next=nodeData.next;else nodeData.listData.first=nodeData.next;if(nodeData.next)nodeData.next.previous=nodeData.previous;else nodeData.listData.last=nodeData.previous;nodeData.previous=null,nodeData.next=null,nodeData.listData.length--}return nodeData.node}clear(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data,nodeData=listData.first;listData.first=null,listData.last=null,listData.length=0;while(nodeData){let next=nodeData.next;nodeData.listData=null,nodeData.previous=null,nodeData.next=null,nodeData=next}return this}splice(start,end,target,index){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(!Number.isInteger(start))throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("start");if(!Number.isInteger(end))throw new RangeError("end");else if(end<0||end>currentListData.length-1)throw new RangeError("end");let rangeLength=Math.abs(start-end)+1,targetListData=null;if(target instanceof List){if(targetListData=target.#data,!Number.isInteger(index))throw new TypeError("index");else if(index<0||currentListData===targetListData?index>targetListData.length-rangeLength:index>targetListData.length)throw new RangeError("index");if(targetListData.length+rangeLength>4294967295)throw new RangeError("List length")}else if(target===void 0)targetListData=new List().#data;else throw new TypeError("target");let targetNodeData=null;if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,startNodeData=null,endNodeData=null,currentNodeData=null,previous=null,next=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;while(currentNodeData){if(i>=start&&i<=end){if(currentNodeData.listData=targetListData,i===start){if(startNodeData=currentNodeData,currentNodeData.previous)previous=currentNodeData.previous,previous.next=null}if(i===end){if(endNodeData=currentNodeData,currentNodeData.next)next=currentNodeData.next,next.previous=null,currentNodeData.next=null}}if(startNodeData&&endNodeData)break;if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}if(previous)previous.next=next;else currentListData.first=next;if(next)next.previous=previous;else currentListData.last=previous;currentListData.length-=rangeLength;let append=!1;if(targetListData.length===0)return targetListData.first=startNodeData,targetListData.last=endNodeData,targetListData.length+=rangeLength,targetListData.list;else if(index===0)targetNodeData=targetListData.first;else if(index>=targetListData.length-1){if(targetNodeData=targetListData.last,index===targetListData.length)append=!0}else{if(!targetNodeData){if(index<targetListData.length/2)forwards=!0,currentNodeData=targetListData.first.next,i=1;else forwards=!1,currentNodeData=targetListData.last.previous,i=targetListData.length-2;while(currentNodeData){if(i===index){targetNodeData=currentNodeData;break}if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=endNodeData,endNodeData.next=targetNodeData.next;else targetListData.last=endNodeData;targetNodeData.next=startNodeData,startNodeData.previous=targetNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=startNodeData,startNodeData.previous=targetNodeData.previous;else targetListData.first=startNodeData;targetNodeData.previous=endNodeData,endNodeData.next=targetNodeData}}return targetListData.length+=rangeLength,targetListData.list}toSpliced(start,end,target,index){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(!Number.isInteger(start))throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("start");if(!Number.isInteger(end))throw new RangeError("end");else if(end<0||end>currentListData.length-1)throw new RangeError("end");let rangeLength=Math.abs(start-end)+1,targetListData=null;if(target instanceof List){if(targetListData=target.#data,!Number.isInteger(index))throw new TypeError("index");else if(index<0||currentListData===targetListData?index>targetListData.length-rangeLength:index>targetListData.length)throw new RangeError("index");if(targetListData.length+rangeLength>4294967295)throw new RangeError("List length")}else if(target===void 0)targetListData=new List().#data;else throw new TypeError("target");if(end<start){let _end=end;end=start,start=_end}let newListData=new List().#data,currentNodeData=null,i;currentNodeData=currentListData.first,i=0;while(currentNodeData){if(i>=start&&i<=end)new ListNode(currentNodeData.node.value,targetListData.list,index++);else new ListNode(currentNodeData.node.value,newListData.list,newListData.length);currentNodeData=currentNodeData.next,i++}return newListData.list}fill(value){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return this;let nodeData=thisData.first;while(nodeData)nodeData.node.value=value,nodeData=nodeData.next;return this}reverse(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return this;let currentNodeData=thisData.first;while(currentNodeData){let{previous,next}=currentNodeData;currentNodeData.previous=next,currentNodeData.next=previous,currentNodeData=next}let{first,last}=thisData;return thisData.first=last,thisData.last=first,this}copyWithin(start,end,index,targetEnd=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(!Number.isInteger(start))throw new TypeError("start");else if(!Number.isInteger(end))throw new TypeError("end");else if(!Number.isInteger(index))throw new TypeError("index");let currentListData=this.#data;if(start<0||start>currentListData.length-1)throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("end");else if(index<0||index>currentListData.length-1)throw new RangeError("index");if(typeof targetEnd!=="boolean")throw new TypeError("targetEnd");if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,startNodeData=null,endNodeData=null,currentNodeData=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;while(currentNodeData){if(i>=start&&i<=end){if(i===start)startNodeData=currentNodeData;if(i===end)endNodeData=currentNodeData}if(startNodeData&&endNodeData)break;if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}let targetNodeData;if(index===0)targetNodeData=currentListData.first;else if(index===currentListData.length-1)targetNodeData=currentListData.last;else{if(index<currentListData.length/2)forwards=!0,currentNodeData=currentListData.first.next,i=1;else forwards=!1,currentNodeData=currentListData.last.previous,i=currentListData.length-2;while(currentNodeData){if(i===index){targetNodeData=currentNodeData;break}if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}}if(targetEnd)currentNodeData=endNodeData;else currentNodeData=startNodeData;console.log("current",currentNodeData.node.value,"target",targetNodeData.node.value);let currentValue=currentNodeData.node.value,_currentValue;while(targetNodeData)if(targetEnd){if(_currentValue=currentNodeData.previous?.node.value,targetNodeData.node.value=currentValue,currentValue=_currentValue,currentNodeData===startNodeData)break;currentNodeData=currentNodeData.previous,targetNodeData=targetNodeData.previous}else{if(_currentValue=currentNodeData.next?.node.value,targetNodeData.node.value=currentValue,currentValue=_currentValue,currentNodeData===endNodeData)break;currentNodeData=currentNodeData.next,targetNodeData=targetNodeData.next}return this}slice(start=0,end=this.#data.length-1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(!Number.isInteger(start))throw new TypeError("start");else if(!Number.isInteger(end))throw new TypeError("end");let currentListData=this.#data;if(start<0||start>currentListData.length-1)throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("end");if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,currentNodeData=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;let newList=new List;while(currentNodeData)if(forwards){if(i>=start&&i<=end)new ListNode(currentNodeData.node.value,newList,newList.#data.length);currentNodeData=currentNodeData.next,i++}else{if(i>=start&&i<=end)new ListNode(currentNodeData.node.value,newList,0);currentNodeData=currentNodeData.previous,i--}return newList}includes(value,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return!1;let nodeData=null,i;if(backwards)nodeData=thisData.last,i=thisData.length-1;else nodeData=thisData.first,i=0;while(nodeData){if(nodeData.node.value===value)return!0;if(backwards)nodeData=nodeData.previous,i--;else nodeData=nodeData.next,i++}return!1}indexOf(value,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return-1;let nodeData=null,i;if(backwards)nodeData=thisData.last,i=thisData.length-1;else nodeData=thisData.first,i=0;while(nodeData){if(nodeData.node.value===value)return i;if(backwards)nodeData=nodeData.previous,i--;else nodeData=nodeData.next,i++}return-1}find(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return null;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return nodeData.node;nodeData=nodeData.previous,index--}return null}findIndex(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return-1;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return index;nodeData=nodeData.previous,index--}return-1}some(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return!1;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return!0;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return!1}every(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return!1;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)!==!0)return!1;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return!0}reduce(callback,initialValue,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return initialValue;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData)if(backwards)initialValue=callback.call(self,initialValue,nodeData.node,index,this),nodeData=nodeData.previous,index--;else initialValue=callback.call(self,initialValue,nodeData.node,index,this),nodeData=nodeData.next,index++;return initialValue}filter(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0){if(nodeData.listData===thisData){if(nodeData.previous)nodeData.previous.next=nodeData.next;else nodeData.listData.first=nodeData.next;if(nodeData.next)nodeData.next.previous=nodeData.previous;else nodeData.listData.last=nodeData.previous;nodeData.previous=null,nodeData.next=null,nodeData.listData.length--}}if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return this}toFilter(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data,newList=new List;if(thisData.length===0)return newList;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData)if(backwards){if(callback.call(self,nodeData.node,index,this)===!0)new ListNode(nodeData.node.value,newList,0);nodeData=nodeData.previous,index--}else{if(callback.call(self,nodeData.node,index,this)===!0)new ListNode(nodeData.node.value,newList,newList.#data.length);nodeData=nodeData.next,index++}return newList}map(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData)if(nodeData.node.value=callback.call(self,nodeData.node,index,this),backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++;return this}toMapped(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data,newList=new List;if(thisData.length===0)return newList;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData)if(backwards)new ListNode(callback.call(self,nodeData.node,index,this),newList,0),nodeData=nodeData.previous,index--;else new ListNode(callback.call(self,nodeData.node,index,this),newList,newList.#data.length),nodeData=nodeData.next,index++;return newList}forEach(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data;if(thisData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=thisData.last,index=thisData.length-1;else nodeData=thisData.first,index=0;while(nodeData)if(callback.call(self,nodeData.node,index,this),backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++;return this}concat(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let newList=new List;for(let value of values)if(value[Symbol.iterator])for(let element of value)new ListNode(element,this,this.#data.length);else new ListNode(value,this,this.#data.length);return newList}nodes(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data;if(listData.length===0)return[];let array=new Array(listData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node,nodeData=nodeData.next,i++;return array}values(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data;if(listData.length===0)return[];let array=new Array(listData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node.value,nodeData=nodeData.next,i++;return array}toString(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let thisData=this.#data,listString="";if(thisData.length===0)return listString;listString+=`${thisData.first.node.value}`;let nodeData=thisData.first.next,index=1;while(nodeData)listString+=`,${nodeData.node.value}`,nodeData=nodeData.next,index++;return listString}[Symbol.iterator](){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let listData=this.#data;if(listData.length===0)return[][Symbol.iterator]();let array=new Array(listData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node,nodeData=nodeData.next,i++;return array[Symbol.iterator]()}}export{ListNode,List};
