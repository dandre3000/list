var privateDataMap=new Map;class ListNode{static[Symbol.hasInstance](instance){try{instance.#data}catch(error){return!1}return!0}#data;value;constructor(value,list,index){if(!new.target)throw new TypeError("List.constructor");let currentNodeData=this.#data={node:this,listData:null,previous:null,next:null};this.value=value;let listData=privateDataMap.get(list);if(listData!==void 0){if(listData.length>=List.maxLength)throw new RangeError("argument list length >= 2 ** 24 - 1");if(typeof index!=="number")throw new TypeError("argument index is not a number");if(!Number.isInteger(index))throw new RangeError("argument index is not an integer");else if(index<0||index>listData.length)throw new RangeError("argument index is not valid");let targetNodeData=null,append=!1;if(currentNodeData.listData=listData,listData.length===0){listData.first=listData.last=currentNodeData,listData.length=1;return}else if(index===0)targetNodeData=listData.first;else if(index>=listData.length-1){if(targetNodeData=listData.last,index===listData.length)append=!0}else{let currentNodeData2,forwards,i;if(index<listData.length/2)forwards=!0,currentNodeData2=listData.first.next,i=1;else forwards=!1,currentNodeData2=listData.last.previous,i=listData.length-2;while(currentNodeData2){if(index===i){targetNodeData=currentNodeData2;break}if(forwards)currentNodeData2=currentNodeData2.next,i++;else currentNodeData2=currentNodeData2.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else listData.last=currentNodeData;currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else listData.first=currentNodeData;currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData}listData.length++}else if(list!==void 0)throw new TypeError("argument list is not a List instance")}list(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.listData?this.#data.listData.list:null}previous(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.previous?this.#data.previous.node:null}next(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}return this.#data.next?this.#data.next.node:null}prependTo(node){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let targetNodeData=node.#data,targetListData=targetNodeData.listData;if(node===this)throw new ReferenceError("node");else if(targetListData&&targetListData.length>=List.maxLength)throw new RangeError("length");let currentNodeData=this.#data;if(currentNodeData===targetNodeData.previous)return this;if(!targetListData)targetNodeData.listData=targetListData=privateDataMap.get(new List),targetListData.first=targetNodeData,targetListData.last=targetNodeData,targetListData.length=1;else if(targetListData.length+1>List.maxLength)throw new RangeError("List length");let currentListData=this.#data.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--}if(currentNodeData.listData=targetListData,targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else targetListData.first=currentNodeData;return currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData,targetListData.length++,this}appendTo(node){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let targetNodeData=node.#data,targetListData=targetNodeData.listData;if(node===this)throw new ReferenceError("node");else if(targetListData&&targetListData.length>=List.maxLength)throw new RangeError("length");let currentNodeData=this.#data;if(currentNodeData===targetNodeData.previous)return this;if(!targetListData)targetNodeData.listData=targetListData=privateDataMap.get(new List),targetListData.first=targetNodeData,targetListData.last=targetNodeData,targetListData.length=1;else if(targetListData.length+1>List.maxLength)throw new RangeError("List length");let currentListData=this.#data.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--}if(currentNodeData.listData=targetListData,targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else targetListData.last=currentNodeData;return currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData,targetListData.length++,this}insertInto(list,index){let currentNodeData=this.#data;try{}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let targetListData=privateDataMap.get(list);if(targetListData===void 0)throw new TypeError("list");else if(targetListData.length>=List.maxLength)throw new RangeError("list.length() >= 2 ** 24 - 1");if(typeof index!=="number")throw new TypeError("argument index is not a number");else if(!Number.isInteger(index))throw new RangeError("argument index is not an integer");else if(index<0||index>targetListData.length)throw new RangeError("argument index is not valid");let currentListData=currentNodeData.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentListData.length--,currentNodeData.listData=null}let targetNodeData=null,append=!1;if(currentNodeData.listData=targetListData,targetListData.length===0)return targetListData.first=targetListData.last=currentNodeData,targetListData.length=1,this;else if(index===0)targetNodeData=targetListData.first;else if(index>=targetListData.length-1){if(targetNodeData=targetListData.last,index===targetListData.length)append=!0}else{let forwards,i;if(index<targetListData.length/2)forwards=!0,targetNodeData=targetListData.first.next,i=1;else forwards=!1,targetNodeData=targetListData.last.previous,i=targetListData.length-2;while(targetNodeData){if(index===i)break;if(forwards)targetNodeData=targetNodeData.next,i++;else targetNodeData=targetNodeData.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=currentNodeData,currentNodeData.next=targetNodeData.next;else targetListData.last=currentNodeData;currentNodeData.previous=targetNodeData,targetNodeData.next=currentNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=currentNodeData,currentNodeData.previous=targetNodeData.previous;else targetListData.first=currentNodeData;currentNodeData.next=targetNodeData,targetNodeData.previous=currentNodeData}return targetListData.length++,this}remove(){try{this.#data}catch(error){throw new TypeError('"this" is not an instance of ListNode')}let currentNodeData=this.#data,currentListData=currentNodeData.listData;if(currentListData){if(currentNodeData.previous)currentNodeData.previous.next=currentNodeData.next;else currentListData.first=currentNodeData.next;if(currentNodeData.next)currentNodeData.next.previous=currentNodeData.previous;else currentListData.last=currentNodeData.previous;currentNodeData.previous=null,currentNodeData.next=null,currentListData.length--,currentNodeData.listData=null}return this}}var thisIsNotAList='"this" is not an instance of List';class List{static maxLength=16777215;static[Symbol.hasInstance](instance){try{instance.#data}catch(error){return!1}return!0}#data;constructor(...values){if(!new.target)throw new TypeError("List.constructor");this.#data={list:this,first:null,last:null,length:0},privateDataMap.set(this,this.#data);let length=values[0];if(values.length===1&&typeof length==="number"){if(!Number.isInteger(length)||length<0||length>List.maxLength)throw new RangeError("length");for(let i=0;i<length;i++)new ListNode(void 0,this,0)}else for(let value of values)new ListNode(value,this,this.#data.length)}first(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.first?this.#data.first.node:null}last(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.last?this.#data.last.node:null}length(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}return this.#data.length}at=(index)=>{try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof index!=="number")throw new TypeError("index");let currentListData=this.#data;if(index<0||index>=currentListData.length)return null;else if(!Number.isInteger(index))throw new RangeError("index");let nodeData;if(index===0)nodeData=currentListData.first;else if(index===currentListData.length-1)nodeData=currentListData.last;else{let forwards,i;if(index<currentListData.length/2)forwards=!0,nodeData=currentListData.first.next,i=1;else forwards=!1,nodeData=currentListData.last.previous,i=currentListData.length-2;while(nodeData){if(index===i)break;if(forwards)nodeData=nodeData.next,i++;else nodeData=nodeData.previous,i--}}return nodeData.node};unshift(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(this.#data.length+values.length>List.maxLength)throw new RangeError("length");for(let i=0;i<values.length;i++)new ListNode(values[i],this,i);return this.#data.length}push(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(this.#data.length+values.length>List.maxLength)throw new RangeError("length");for(let value of values)new ListNode(value,this,this.#data.length);return this.#data.length}insert(index,...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let valuesLength=values.length;if(this.#data.length+valuesLength>List.maxLength)throw new RangeError("length");for(let i=0;i<valuesLength;i++)new ListNode(values[i],this,index+i);return this.#data.length}shift(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(!currentListData.first)return null;else{let nodeData=currentListData.first;if(nodeData.next)nodeData.next.previous=null,currentListData.first=nodeData.next;else currentListData.first=currentListData.last=null;return currentListData.length--,nodeData.previous=null,nodeData.next=null,nodeData.listData=null,nodeData.node}}pop(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(!currentListData.last)return null;else{let nodeData=currentListData.last;if(nodeData.previous)nodeData.previous.next=null,currentListData.last=nodeData.previous;else currentListData.first=currentListData.last=null;return currentListData.length--,nodeData.previous=null,nodeData.next=null,nodeData.listData=null,nodeData.node}}remove(index){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof index!=="number")throw new TypeError("index");else if(!Number.isInteger(index))throw new RangeError("index");let currentListData=this.#data;if(index<0||index>currentListData.length-1)throw new RangeError("index");let nodeData=null;if(index===0)nodeData=currentListData.first;else if(index===currentListData.length-1)nodeData=currentListData.last;else{let forwards,i;if(index<currentListData.length/2)forwards=!0,nodeData=currentListData.first.next,i=1;else forwards=!1,nodeData=currentListData.last.previous,i=currentListData.length-2;while(nodeData){if(index===i)break;if(forwards)nodeData=nodeData.next,i++;else nodeData=nodeData.previous,i--}}if(nodeData.previous)nodeData.previous.next=nodeData.next;else nodeData.listData.first=nodeData.next;if(nodeData.next)nodeData.next.previous=nodeData.previous;else nodeData.listData.last=nodeData.previous;return nodeData.previous=null,nodeData.next=null,nodeData.listData=null,currentListData.length--,nodeData.node}clear(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data,nodeData=currentListData.first;currentListData.first=null,currentListData.last=null,currentListData.length=0;while(nodeData){let next=nodeData.next;nodeData.listData=null,nodeData.previous=null,nodeData.next=null,nodeData=next}return this}splice(start,end,list,index){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(typeof start!=="number")throw new TypeError("start");else if(!Number.isInteger(start))throw new RangeError("start");else if(start<0||start>currentListData.length-1)throw new RangeError("start");if(typeof end!=="number")throw new TypeError("end");if(!Number.isInteger(end))throw new RangeError("end");else if(end<0||end>currentListData.length-1)throw new RangeError("end");let rangeLength=Math.abs(start-end)+1,targetListData=null;if(list instanceof List){if(targetListData=list.#data,typeof index!=="number")throw new TypeError("index");else if(!Number.isInteger(index))throw new RangeError("index");else if(index<0||index>(currentListData===targetListData?targetListData.length-rangeLength:targetListData.length))throw new RangeError("index");else if(currentListData!==targetListData&&targetListData.length+rangeLength>List.maxLength)throw new RangeError("List length")}else if(list===void 0)targetListData=new List().#data;else throw new TypeError("list");let targetNodeData=null;if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,startNodeData=null,endNodeData=null,currentNodeData=null,previous=null,next=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;while(currentNodeData){if(i>=start&&i<=end){if(currentNodeData.listData=targetListData,i===start){if(startNodeData=currentNodeData,currentNodeData.previous)previous=currentNodeData.previous;currentNodeData.previous=null}if(i===end){if(endNodeData=currentNodeData,currentNodeData.next)next=currentNodeData.next;currentNodeData.next=null}}if(startNodeData&&endNodeData)break;if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}if(previous)previous.next=next;else currentListData.first=next;if(next)next.previous=previous;else currentListData.last=previous;currentListData.length-=rangeLength;let append=!1;if(targetListData.length===0)return targetListData.first=startNodeData,targetListData.last=endNodeData,targetListData.length+=rangeLength,targetListData.list;else if(index===0)targetNodeData=targetListData.first;else if(index>=targetListData.length-1){if(targetNodeData=targetListData.last,index===targetListData.length)append=!0}else if(!targetNodeData){if(index<targetListData.length/2)forwards=!0,currentNodeData=targetListData.first.next,i=1;else forwards=!1,currentNodeData=targetListData.last.previous,i=targetListData.length-2;while(currentNodeData){if(i===index){targetNodeData=currentNodeData;break}if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}}if(append){if(targetNodeData.next)targetNodeData.next.previous=endNodeData;else targetListData.last=endNodeData;startNodeData.previous=targetNodeData,endNodeData.next=targetNodeData.next,targetNodeData.next=startNodeData}else{if(targetNodeData.previous)targetNodeData.previous.next=startNodeData;else targetListData.first=startNodeData;startNodeData.previous=targetNodeData.previous,endNodeData.next=targetNodeData,targetNodeData.previous=endNodeData}return targetListData.length+=rangeLength,targetListData.list}fill(value){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(currentListData.length===0)return this;let nodeData=currentListData.first;while(nodeData)nodeData.node.value=value,nodeData=nodeData.next;return this}reverse(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(currentListData.length===0)return this;let currentNodeData=currentListData.first;while(currentNodeData){let{previous,next}=currentNodeData;currentNodeData.previous=next,currentNodeData.next=previous,currentNodeData=next}let{first,last}=currentListData;return currentListData.first=last,currentListData.last=first,this}copyWithin(start,end,target,targetEnd=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof start!=="number")throw new TypeError("start");else if(!Number.isInteger(start))throw new RangeError("start");else if(typeof end!=="number")throw new TypeError("end");else if(!Number.isInteger(end))throw new RangeError("end");else if(typeof target!=="number")throw new TypeError("target");else if(!Number.isInteger(target))throw new RangeError("target");let currentListData=this.#data;if(start<0||start>currentListData.length-1)throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("end");else if(target<0||target>currentListData.length-1)throw new RangeError("target");if(typeof targetEnd!=="boolean")throw new TypeError("targetEnd");if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,startNodeData=null,endNodeData=null,currentNodeData=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;while(currentNodeData){if(i>=start&&i<=end){if(i===start)startNodeData=currentNodeData;if(i===end)endNodeData=currentNodeData}if(startNodeData&&endNodeData)break;if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}let targetNodeData;if(target===0)targetNodeData=currentListData.first;else if(target===currentListData.length-1)targetNodeData=currentListData.last;else{if(target<currentListData.length/2)forwards=!0,currentNodeData=currentListData.first.next,i=1;else forwards=!1,currentNodeData=currentListData.last.previous,i=currentListData.length-2;while(currentNodeData){if(i===target){targetNodeData=currentNodeData;break}if(forwards)currentNodeData=currentNodeData.next,i++;else currentNodeData=currentNodeData.previous,i--}}if(targetEnd)currentNodeData=endNodeData;else currentNodeData=startNodeData;let currentValue=currentNodeData.node.value,_currentValue;while(targetNodeData)if(targetEnd){if(_currentValue=currentNodeData.previous?.node.value,targetNodeData.node.value=currentValue,currentValue=_currentValue,currentNodeData===startNodeData)break;currentNodeData=currentNodeData.previous,targetNodeData=targetNodeData.previous}else{if(_currentValue=currentNodeData.next?.node.value,targetNodeData.node.value=currentValue,currentValue=_currentValue,currentNodeData===endNodeData)break;currentNodeData=currentNodeData.next,targetNodeData=targetNodeData.next}return this}slice(start=0,end=this.#data.length-1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof start!=="number")throw new TypeError("start");else if(!Number.isInteger(start))throw new RangeError("start");else if(typeof end!=="number")throw new TypeError("end");else if(!Number.isInteger(end))throw new RangeError("end");let currentListData=this.#data;if(start<0||start>currentListData.length-1)throw new RangeError("start");else if(end<0||end>currentListData.length-1)throw new RangeError("end");if(end<start){let _end=end;end=start,start=_end}let forwards=start>currentListData.length-end-1?!1:!0,currentNodeData=null,i;if(forwards)currentNodeData=currentListData.first,i=0;else currentNodeData=currentListData.last,i=currentListData.length-1;let newList=new List;while(currentNodeData)if(forwards){if(i>=start&&i<=end)new ListNode(currentNodeData.node.value,newList,newList.#data.length);currentNodeData=currentNodeData.next,i++}else{if(i>=start&&i<=end)new ListNode(currentNodeData.node.value,newList,0);currentNodeData=currentNodeData.previous,i--}return newList}includes(value,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return!1;let nodeData=null,i;if(backwards)nodeData=currentListData.last,i=currentListData.length-1;else nodeData=currentListData.first,i=0;while(nodeData){if(nodeData.node.value===value)return!0;if(backwards)nodeData=nodeData.previous,i--;else nodeData=nodeData.next,i++}return!1}indexOf(value,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return-1;let nodeData=null,i;if(backwards)nodeData=currentListData.last,i=currentListData.length-1;else nodeData=currentListData.first,i=0;while(nodeData){if(nodeData.node.value===value)return i;if(backwards)nodeData=nodeData.previous,i--;else nodeData=nodeData.next,i++}return-1}find(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return null;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return nodeData.node;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return null}findIndex(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return-1;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return index;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return-1}some(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return!1;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)===!0)return!0;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return!1}every(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return!1;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData){if(callback.call(self,nodeData.node,index,this)!==!0)return!1;if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}return!0}reduce(callback,initialValue,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return initialValue;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData)if(backwards)initialValue=callback.call(self,initialValue,nodeData.node,index,this),nodeData=nodeData.previous,index--;else initialValue=callback.call(self,initialValue,nodeData.node,index,this),nodeData=nodeData.next,index++;return initialValue}filter(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;let nodeDataArray=[];while(nodeData){let adjacent=backwards?nodeData.previous:nodeData.next;if(callback.call(self,nodeData.node,index,this)===!0)nodeDataArray.push(nodeData);if(backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++}for(let nodeData2 of nodeDataArray){if(nodeData2.previous)nodeData2.previous.next=nodeData2.next;else nodeData2.listData.first=nodeData2.next;if(nodeData2.next)nodeData2.next.previous=nodeData2.previous;else nodeData2.listData.last=nodeData2.previous;nodeData2.previous=null,nodeData2.next=null,nodeData2.listData=null,currentListData.length--}return this}map(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;let values=[];while(nodeData)if(values.push(callback.call(self,nodeData.node,index,this)),backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++;nodeData=currentListData.first,index=0;while(nodeData)nodeData.node.value=values[index],nodeData=nodeData.next,index++;return this}forEach(callback,self=null,backwards=!1){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}if(typeof backwards!=="boolean")throw new TypeError("backwards");let currentListData=this.#data;if(currentListData.length===0)return this;let nodeData=null,index;if(backwards)nodeData=currentListData.last,index=currentListData.length-1;else nodeData=currentListData.first,index=0;while(nodeData)if(callback.call(self,nodeData.node,index,this),backwards)nodeData=nodeData.previous,index--;else nodeData=nodeData.next,index++;return this}concat(...values){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let length=this.#data.length;if(length+values.length>List.maxLength)throw new RangeError("length");for(let value of values){if(typeof value==="object"&&typeof value.length==="number")length+=value.length;else if(value instanceof Set||value instanceof Map)length+=value.size;else length++;if(length>List.maxLength)throw new RangeError("length")}let newList=new List;for(let value of values)if(typeof value==="object"&&typeof value.length==="number")for(let i=0;i<value.length;i++)new ListNode(value[i],this,this.#data.length);else if(value instanceof Set)for(let element of value)new ListNode(element,this,this.#data.length);else if(value instanceof Map)for(let[key,element]of value)new ListNode(element,this,this.#data.length);else new ListNode(value,this,this.#data.length);return newList}nodes(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(currentListData.length===0)return[];let array=new Array(currentListData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node,nodeData=nodeData.next,i++;return array}values(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(currentListData.length===0)return[];let array=new Array(currentListData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node.value,nodeData=nodeData.next,i++;return array}toString(){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data,listString="";if(currentListData.length===0)return listString;listString+=`${currentListData.first.node.value}`;let nodeData=currentListData.first.next,index=1;while(nodeData)listString+=`,${nodeData.node.value}`,nodeData=nodeData.next,index++;return listString}[Symbol.iterator](){try{this.#data}catch(error){throw new TypeError(thisIsNotAList)}let currentListData=this.#data;if(currentListData.length===0)return[][Symbol.iterator]();let array=new Array(currentListData.length),nodeData=this.#data.first,i=0;while(nodeData)array[i]=nodeData.node,nodeData=nodeData.next,i++;return array[Symbol.iterator]()}}Object.defineProperty(List,"maxLength",{configurable:!1,writable:!1,enumerable:!0,value:List.maxLength});export{ListNode,List};
